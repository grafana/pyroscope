0a1
> hot-cg before inline in dot format:
148,152c149,153
< ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:36:6: cannot inline zeropool.(*Pool[go.shape.[]int64]).Get: function too complex: cost 164 exceeds budget 80
< ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:57:6: cannot inline zeropool.(*Pool[go.shape.[]int64]).Put: function too complex: cost 156 exceeds budget 80
< ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.string,go.shape.string,go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 837 exceeds budget 80
< ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:57:6: can inline zeropool.(*Pool[[]int64]).Put with cost 62 as: method(*zeropool.Pool[[]int64]) func([]int64) { (*zeropool.Pool[go.shape.[]int64]).Put(zeropool.p, &zeropool..dict.Pool[[]int64], zeropool.item) }
< ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:36:6: can inline zeropool.(*Pool[[]int64]).Get with cost 62 as: method(*zeropool.Pool[[]int64]) func() []int64 { return (*zeropool.Pool[go.shape.[]int64]).Get(zeropool.p, &zeropool..dict.Pool[[]int64]) }
---
> ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:36:6: can inline zeropool.(*Pool[go.shape.[]int64]).Get with cost 164 as: method(*zeropool.Pool[go.shape.[]int64]) func(*[9]uintptr) go.shape.[]int64 { zeropool.pooled := (*sync.Pool).Get(zeropool.p.items); if zeropool.pooled == nil { zeropool.zero = <nil>; return zeropool.zero }; zeropool.ptr := <node DYNAMICDOTTYPE>; zeropool.item := *zeropool.ptr; zeropool.zero = <nil>; *zeropool.ptr = zeropool.zero; (*sync.Pool).Put(zeropool.p.pointers, zeropool.ptr); return zeropool.item }
> ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:57:6: can inline zeropool.(*Pool[go.shape.[]int64]).Put with cost 156 as: method(*zeropool.Pool[go.shape.[]int64]) func(*[9]uintptr, go.shape.[]int64) { zeropool.ptr = <nil>; if zeropool.pooled != nil { zeropool.ptr = <node DYNAMICDOTTYPE> } else { zeropool.ptr = new(<node DYNAMICTYPE>) }; *zeropool.ptr = zeropool.item; (*sync.Pool).Put(zeropool.p.items, zeropool.ptr) }
> ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.string,go.shape.string,go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 1043 exceeds budget 80
> ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:57:6: cannot inline zeropool.(*Pool[[]int64]).Put: function too complex: cost 161 exceeds budget 80
> ../../go/pkg/mod/github.com/colega/zeropool@v0.0.0-20230505084239-6fb4a4f75381/pool.go:36:6: cannot inline zeropool.(*Pool[[]int64]).Get: function too complex: cost 169 exceeds budget 80
154c155
< ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.string,go.shape.string,go.shape.*uint8,go.shape.*uint8]).ingest: function too complex: cost 1387 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[go.shape.string,go.shape.string,go.shape.*uint8,go.shape.*uint8]).ingest with cost 1593 as: method(*phlaredb.deduplicatingSlice[go.shape.string,go.shape.string,go.shape.*uint8,go.shape.*uint8]) func(*[35]uintptr, context.Context, []go.shape.string, *phlaredb.rewriter) error { phlaredb.rewritingMap := make(map[int64]int64); phlaredb.missing := (*zeropool.Pool[go.shape.[]int64]).Get(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64]); phlaredb.missing = phlaredb.missing[:0]; for loop; (*sync.RWMutex).RLock(phlaredb.s.lock); for loop; (*sync.RWMutex).RUnlock(phlaredb.s.lock); if len(phlaredb.missing) > 0 { (*sync.RWMutex).Lock(phlaredb.s.lock); phlaredb.posSlice := int64(len(phlaredb.s.slice)); for loop; (*sync.RWMutex).Unlock(phlaredb.s.lock) }; (*zeropool.Pool[go.shape.[]int64]).Put(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64], phlaredb.missing); (func(go.shape.*uint8, *phlaredb.rewriter, phlaredb.idConversionTable))(&phlaredb..dict[9])(phlaredb.s.helper, phlaredb.rewriter, phlaredb.rewritingMap); return nil }
175c176
< ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,go.shape.struct { MemoryStart uint64; MemoryLimit uint64; FileOffset uint64; Filename uint32; BuildId uint32; HasFunctions bool; HasFilenames bool; HasLineNumbers bool; HasInlineFrames bool },go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 837 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,go.shape.struct { MemoryStart uint64; MemoryLimit uint64; FileOffset uint64; Filename uint32; BuildId uint32; HasFunctions bool; HasFilenames bool; HasLineNumbers bool; HasInlineFrames bool },go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 1043 exceeds budget 80
177c178
< ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,go.shape.struct { MemoryStart uint64; MemoryLimit uint64; FileOffset uint64; Filename uint32; BuildId uint32; HasFunctions bool; HasFilenames bool; HasLineNumbers bool; HasInlineFrames bool },go.shape.*uint8,go.shape.*uint8]).ingest: function too complex: cost 1387 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,go.shape.struct { MemoryStart uint64; MemoryLimit uint64; FileOffset uint64; Filename uint32; BuildId uint32; HasFunctions bool; HasFilenames bool; HasLineNumbers bool; HasInlineFrames bool },go.shape.*uint8,go.shape.*uint8]).ingest with cost 1593 as: method(*phlaredb.deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,go.shape.struct { MemoryStart uint64; MemoryLimit uint64; FileOffset uint64; Filename uint32; BuildId uint32; HasFunctions bool; HasFilenames bool; HasLineNumbers bool; HasInlineFrames bool },go.shape.*uint8,go.shape.*uint8]) func(*[35]uintptr, context.Context, []go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping, *phlaredb.rewriter) error { phlaredb.rewritingMap := make(map[int64]int64); phlaredb.missing := (*zeropool.Pool[go.shape.[]int64]).Get(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64]); phlaredb.missing = phlaredb.missing[:0]; for loop; (*sync.RWMutex).RLock(phlaredb.s.lock); for loop; (*sync.RWMutex).RUnlock(phlaredb.s.lock); if len(phlaredb.missing) > 0 { (*sync.RWMutex).Lock(phlaredb.s.lock); phlaredb.posSlice := int64(len(phlaredb.s.slice)); for loop; (*sync.RWMutex).Unlock(phlaredb.s.lock) }; (*zeropool.Pool[go.shape.[]int64]).Put(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64], phlaredb.missing); (func(go.shape.*uint8, *phlaredb.rewriter, phlaredb.idConversionTable))(&phlaredb..dict[9])(phlaredb.s.helper, phlaredb.rewriter, phlaredb.rewritingMap); return nil }
184c185
< ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,go.shape.struct { Name uint32; SystemName uint32; Filename uint32; StartLine uint32 },go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 837 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,go.shape.struct { Name uint32; SystemName uint32; Filename uint32; StartLine uint32 },go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 1043 exceeds budget 80
186c187
< ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,go.shape.struct { Name uint32; SystemName uint32; Filename uint32; StartLine uint32 },go.shape.*uint8,go.shape.*uint8]).ingest: function too complex: cost 1387 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,go.shape.struct { Name uint32; SystemName uint32; Filename uint32; StartLine uint32 },go.shape.*uint8,go.shape.*uint8]).ingest with cost 1593 as: method(*phlaredb.deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,go.shape.struct { Name uint32; SystemName uint32; Filename uint32; StartLine uint32 },go.shape.*uint8,go.shape.*uint8]) func(*[35]uintptr, context.Context, []go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction, *phlaredb.rewriter) error { phlaredb.rewritingMap := make(map[int64]int64); phlaredb.missing := (*zeropool.Pool[go.shape.[]int64]).Get(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64]); phlaredb.missing = phlaredb.missing[:0]; for loop; (*sync.RWMutex).RLock(phlaredb.s.lock); for loop; (*sync.RWMutex).RUnlock(phlaredb.s.lock); if len(phlaredb.missing) > 0 { (*sync.RWMutex).Lock(phlaredb.s.lock); phlaredb.posSlice := int64(len(phlaredb.s.slice)); for loop; (*sync.RWMutex).Unlock(phlaredb.s.lock) }; (*zeropool.Pool[go.shape.[]int64]).Put(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64], phlaredb.missing); (func(go.shape.*uint8, *phlaredb.rewriter, phlaredb.idConversionTable))(&phlaredb..dict[9])(phlaredb.s.helper, phlaredb.rewriter, phlaredb.rewritingMap); return nil }
193c194
< ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,go.shape.struct { MappingId uint32; Address uint64; LinesHash uint64 },go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 837 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:231:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,go.shape.struct { MappingId uint32; Address uint64; LinesHash uint64 },go.shape.*uint8,go.shape.*uint8]).append: function too complex: cost 1043 exceeds budget 80
195c196
< ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,go.shape.struct { MappingId uint32; Address uint64; LinesHash uint64 },go.shape.*uint8,go.shape.*uint8]).ingest: function too complex: cost 1387 exceeds budget 80
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,go.shape.struct { MappingId uint32; Address uint64; LinesHash uint64 },go.shape.*uint8,go.shape.*uint8]).ingest with cost 1593 as: method(*phlaredb.deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,go.shape.struct { MappingId uint32; Address uint64; LinesHash uint64 },go.shape.*uint8,go.shape.*uint8]) func(*[35]uintptr, context.Context, []go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation, *phlaredb.rewriter) error { phlaredb.rewritingMap := make(map[int64]int64); phlaredb.missing := (*zeropool.Pool[go.shape.[]int64]).Get(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64]); phlaredb.missing = phlaredb.missing[:0]; for loop; (*sync.RWMutex).RLock(phlaredb.s.lock); for loop; (*sync.RWMutex).RUnlock(phlaredb.s.lock); if len(phlaredb.missing) > 0 { (*sync.RWMutex).Lock(phlaredb.s.lock); phlaredb.posSlice := int64(len(phlaredb.s.slice)); for loop; (*sync.RWMutex).Unlock(phlaredb.s.lock) }; (*zeropool.Pool[go.shape.[]int64]).Put(phlaredb.int64SlicePool, &zeropool..dict.Pool[[]int64], phlaredb.missing); (func(go.shape.*uint8, *phlaredb.rewriter, phlaredb.idConversionTable))(&phlaredb..dict[9])(phlaredb.s.helper, phlaredb.rewriter, phlaredb.rewritingMap); return nil }
498c499
< ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,github.com/grafana/pyroscope/pkg/phlaredb.locationsKey,*github.com/grafana/pyroscope/pkg/phlaredb.locationsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.LocationPersister]).ingest with cost 69 as: method(*phlaredb.deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,github.com/grafana/pyroscope/pkg/phlaredb.locationsKey,*github.com/grafana/pyroscope/pkg/phlaredb.locationsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.LocationPersister]) func(context.Context, []*v1.InMemoryLocation, *phlaredb.rewriter) error { var .autotmp_4 context.Context; .autotmp_4 = <nil>; return (*phlaredb.deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,go.shape.struct { MappingId uint32; Address uint64; LinesHash uint64 },go.shape.*uint8,go.shape.*uint8]).ingest(phlaredb.s, &phlaredb..dict.deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,github.com/grafana/pyroscope/pkg/phlaredb.locationsKey,*github.com/grafana/pyroscope/pkg/phlaredb.locationsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.LocationPersister], .autotmp_4, phlaredb.elems, phlaredb.rewriter) }
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryLocation,github.com/grafana/pyroscope/pkg/phlaredb.locationsKey,*github.com/grafana/pyroscope/pkg/phlaredb.locationsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.LocationPersister]).ingest: function too complex: cost 1605 exceeds budget 80
518c519
< ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,github.com/grafana/pyroscope/pkg/phlaredb.functionsKey,*github.com/grafana/pyroscope/pkg/phlaredb.functionsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.FunctionPersister]).ingest with cost 69 as: method(*phlaredb.deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,github.com/grafana/pyroscope/pkg/phlaredb.functionsKey,*github.com/grafana/pyroscope/pkg/phlaredb.functionsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.FunctionPersister]) func(context.Context, []*v1.InMemoryFunction, *phlaredb.rewriter) error { var .autotmp_4 context.Context; .autotmp_4 = <nil>; return (*phlaredb.deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,go.shape.struct { Name uint32; SystemName uint32; Filename uint32; StartLine uint32 },go.shape.*uint8,go.shape.*uint8]).ingest(phlaredb.s, &phlaredb..dict.deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,github.com/grafana/pyroscope/pkg/phlaredb.functionsKey,*github.com/grafana/pyroscope/pkg/phlaredb.functionsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.FunctionPersister], .autotmp_4, phlaredb.elems, phlaredb.rewriter) }
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryFunction,github.com/grafana/pyroscope/pkg/phlaredb.functionsKey,*github.com/grafana/pyroscope/pkg/phlaredb.functionsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.FunctionPersister]).ingest: function too complex: cost 1605 exceeds budget 80
538c539
< ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,github.com/grafana/pyroscope/pkg/phlaredb.mappingsKey,*github.com/grafana/pyroscope/pkg/phlaredb.mappingsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.MappingPersister]).ingest with cost 69 as: method(*phlaredb.deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,github.com/grafana/pyroscope/pkg/phlaredb.mappingsKey,*github.com/grafana/pyroscope/pkg/phlaredb.mappingsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.MappingPersister]) func(context.Context, []*v1.InMemoryMapping, *phlaredb.rewriter) error { var .autotmp_4 context.Context; .autotmp_4 = <nil>; return (*phlaredb.deduplicatingSlice[go.shape.*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,go.shape.struct { MemoryStart uint64; MemoryLimit uint64; FileOffset uint64; Filename uint32; BuildId uint32; HasFunctions bool; HasFilenames bool; HasLineNumbers bool; HasInlineFrames bool },go.shape.*uint8,go.shape.*uint8]).ingest(phlaredb.s, &phlaredb..dict.deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,github.com/grafana/pyroscope/pkg/phlaredb.mappingsKey,*github.com/grafana/pyroscope/pkg/phlaredb.mappingsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.MappingPersister], .autotmp_4, phlaredb.elems, phlaredb.rewriter) }
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.InMemoryMapping,github.com/grafana/pyroscope/pkg/phlaredb.mappingsKey,*github.com/grafana/pyroscope/pkg/phlaredb.mappingsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.MappingPersister]).ingest: function too complex: cost 1605 exceeds budget 80
558c559
< ./pkg/phlaredb/deduplicating_slice.go:173:6: can inline phlaredb.(*deduplicatingSlice[string,string,*github.com/grafana/pyroscope/pkg/phlaredb.stringsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.StringPersister]).ingest with cost 69 as: method(*phlaredb.deduplicatingSlice[string,string,*github.com/grafana/pyroscope/pkg/phlaredb.stringsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.StringPersister]) func(context.Context, []string, *phlaredb.rewriter) error { var .autotmp_4 context.Context; .autotmp_4 = <nil>; return (*phlaredb.deduplicatingSlice[go.shape.string,go.shape.string,go.shape.*uint8,go.shape.*uint8]).ingest(phlaredb.s, &phlaredb..dict.deduplicatingSlice[string,string,*github.com/grafana/pyroscope/pkg/phlaredb.stringsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.StringPersister], .autotmp_4, phlaredb.elems, phlaredb.rewriter) }
---
> ./pkg/phlaredb/deduplicating_slice.go:173:6: cannot inline phlaredb.(*deduplicatingSlice[string,string,*github.com/grafana/pyroscope/pkg/phlaredb.stringsHelper,*github.com/grafana/pyroscope/pkg/phlaredb/schemas/v1.StringPersister]).ingest: function too complex: cost 1605 exceeds budget 80
