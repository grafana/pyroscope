// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: v0.6.0
// source: fuzz/types.proto

package fuzz

import (
	binary "encoding/binary"
	fmt "fmt"
	v1 "github.com/grafana/pyroscope/api/gen/proto/go/settings/v1"
	protohelpers "github.com/planetscale/vtprotobuf/protohelpers"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	math "math"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *IngestlimitsConfig) CloneVT() *IngestlimitsConfig {
	if m == nil {
		return (*IngestlimitsConfig)(nil)
	}
	r := new(IngestlimitsConfig)
	r.PeriodType = m.PeriodType
	r.PeriodLimitMb = m.PeriodLimitMb
	r.LimitResetTime = m.LimitResetTime
	r.LimitReached = m.LimitReached
	r.IngestlimitsSamplingConfig__NumRequests = m.IngestlimitsSamplingConfig__NumRequests
	r.IngestlimitsSamplingConfig__Period = m.IngestlimitsSamplingConfig__Period
	if rhs := m.UsageGroups; rhs != nil {
		tmpContainer := make(map[string]*IngestlimitsUsageGroup, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UsageGroups = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *IngestlimitsConfig) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *IngestlimitsUsageGroup) CloneVT() *IngestlimitsUsageGroup {
	if m == nil {
		return (*IngestlimitsUsageGroup)(nil)
	}
	r := new(IngestlimitsUsageGroup)
	r.PeriodLimitMb = m.PeriodLimitMb
	r.LimitReached = m.LimitReached
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *IngestlimitsUsageGroup) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *RelabelConfig) CloneVT() *RelabelConfig {
	if m == nil {
		return (*RelabelConfig)(nil)
	}
	r := new(RelabelConfig)
	r.Separator = m.Separator
	r.Regex = m.Regex
	r.Modulus = m.Modulus
	r.TargetLabel = m.TargetLabel
	r.Replacement = m.Replacement
	r.Action = m.Action
	if rhs := m.SourceLabels; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.SourceLabels = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *RelabelConfig) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *SamplingConfig) CloneVT() *SamplingConfig {
	if m == nil {
		return (*SamplingConfig)(nil)
	}
	r := new(SamplingConfig)
	if rhs := m.UsageGroups; rhs != nil {
		tmpContainer := make(map[string]*SamplingUsageGroupSampling, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UsageGroups = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SamplingConfig) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *SamplingUsageGroupSampling) CloneVT() *SamplingUsageGroupSampling {
	if m == nil {
		return (*SamplingUsageGroupSampling)(nil)
	}
	r := new(SamplingUsageGroupSampling)
	r.Probability = m.Probability
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SamplingUsageGroupSampling) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *ValidationLimits) CloneVT() *ValidationLimits {
	if m == nil {
		return (*ValidationLimits)(nil)
	}
	r := new(ValidationLimits)
	r.IngestionRateMB = m.IngestionRateMB
	r.IngestionBurstSizeMB = m.IngestionBurstSizeMB
	r.IngestionLimit = m.IngestionLimit.CloneVT()
	r.IngestionBodyLimitMB = m.IngestionBodyLimitMB
	r.DistributorSampling = m.DistributorSampling.CloneVT()
	r.MaxLabelNameLength = m.MaxLabelNameLength
	r.MaxLabelValueLength = m.MaxLabelValueLength
	r.MaxLabelNamesPerSeries = m.MaxLabelNamesPerSeries
	r.MaxSessionsPerSeries = m.MaxSessionsPerSeries
	r.EnforceLabelsOrder = m.EnforceLabelsOrder
	r.MaxProfileSizeBytes = m.MaxProfileSizeBytes
	r.MaxProfileStacktraceSamples = m.MaxProfileStacktraceSamples
	r.MaxProfileStacktraceSampleLabels = m.MaxProfileStacktraceSampleLabels
	r.MaxProfileStacktraceDepth = m.MaxProfileStacktraceDepth
	r.MaxProfileSymbolValueLength = m.MaxProfileSymbolValueLength
	r.DistributorAggregationWindow = m.DistributorAggregationWindow
	r.DistributorAggregationPeriod = m.DistributorAggregationPeriod
	r.IngestionRelabelingDefaultRulesPosition = m.IngestionRelabelingDefaultRulesPosition
	r.IngestionTenantShardSize = m.IngestionTenantShardSize
	r.IngestionArtificialDelay = m.IngestionArtificialDelay
	r.MaxLocalSeriesPerTenant = m.MaxLocalSeriesPerTenant
	r.MaxGlobalSeriesPerTenant = m.MaxGlobalSeriesPerTenant
	r.MaxQueryLookback = m.MaxQueryLookback
	r.MaxQueryLength = m.MaxQueryLength
	r.MaxQueryParallelism = m.MaxQueryParallelism
	r.QueryAnalysisEnabled = m.QueryAnalysisEnabled
	r.QueryAnalysisSeriesEnabled = m.QueryAnalysisSeriesEnabled
	r.MaxFlameGraphNodesDefault = m.MaxFlameGraphNodesDefault
	r.MaxFlameGraphNodesMax = m.MaxFlameGraphNodesMax
	r.StoreGatewayTenantShardSize = m.StoreGatewayTenantShardSize
	r.QuerySplitDuration = m.QuerySplitDuration
	r.CompactorBlocksRetentionPeriod = m.CompactorBlocksRetentionPeriod
	r.CompactorSplitAndMergeShards = m.CompactorSplitAndMergeShards
	r.CompactorSplitAndMergeStageSize = m.CompactorSplitAndMergeStageSize
	r.CompactorSplitGroups = m.CompactorSplitGroups
	r.CompactorTenantShardSize = m.CompactorTenantShardSize
	r.CompactorPartialBlockDeletionDelay = m.CompactorPartialBlockDeletionDelay
	r.CompactorDownsamplerEnabled = m.CompactorDownsamplerEnabled
	r.S3SSEType = m.S3SSEType
	r.S3SSEKMSKeyID = m.S3SSEKMSKeyID
	r.S3SSEKMSEncryptionContext = m.S3SSEKMSEncryptionContext
	r.RejectOlderThan = m.RejectOlderThan
	r.RejectNewerThan = m.RejectNewerThan
	r.WritepathConfig__WritePath = m.WritepathConfig__WritePath
	r.WritepathConfig__IngesterWeight = m.WritepathConfig__IngesterWeight
	r.WritepathConfig__SegmentWriterWeight = m.WritepathConfig__SegmentWriterWeight
	r.WritepathConfig__SegmentWriterTimeout = m.WritepathConfig__SegmentWriterTimeout
	r.WritepathConfig__Compression = m.WritepathConfig__Compression
	r.WritepathConfig__AsyncIngest = m.WritepathConfig__AsyncIngest
	r.ReadpathConfig__EnableQueryBackend = m.ReadpathConfig__EnableQueryBackend
	r.ReadpathConfig__EnableQueryBackendFrom = m.ReadpathConfig__EnableQueryBackendFrom
	r.RetentionConfig__RetentionPeriod = m.RetentionConfig__RetentionPeriod
	r.AdaptiveplacementPlacementLimits__TenantShards = m.AdaptiveplacementPlacementLimits__TenantShards
	r.AdaptiveplacementPlacementLimits__DefaultDatasetShards = m.AdaptiveplacementPlacementLimits__DefaultDatasetShards
	r.AdaptiveplacementPlacementLimits__LoadBalancing = m.AdaptiveplacementPlacementLimits__LoadBalancing
	r.AdaptiveplacementPlacementLimits__MinDatasetShards = m.AdaptiveplacementPlacementLimits__MinDatasetShards
	r.AdaptiveplacementPlacementLimits__MaxDatasetShards = m.AdaptiveplacementPlacementLimits__MaxDatasetShards
	r.AdaptiveplacementPlacementLimits__UnitSizeBytes = m.AdaptiveplacementPlacementLimits__UnitSizeBytes
	r.AdaptiveplacementPlacementLimits__BurstWindow = m.AdaptiveplacementPlacementLimits__BurstWindow
	r.AdaptiveplacementPlacementLimits__DecayWindow = m.AdaptiveplacementPlacementLimits__DecayWindow
	r.ValidationSymbolizer__Enabled = m.ValidationSymbolizer__Enabled
	if rhs := m.DistributorUsageGroups; rhs != nil {
		tmpContainer := make(map[string]string, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.DistributorUsageGroups = tmpContainer
	}
	if rhs := m.IngestionRelabelingRules; rhs != nil {
		tmpContainer := make([]*RelabelConfig, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.IngestionRelabelingRules = tmpContainer
	}
	if rhs := m.RecordingRules; rhs != nil {
		tmpContainer := make([]*v1.RecordingRule, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *v1.RecordingRule }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*v1.RecordingRule)
			}
		}
		r.RecordingRules = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ValidationLimits) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (this *IngestlimitsConfig) EqualVT(that *IngestlimitsConfig) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.PeriodType != that.PeriodType {
		return false
	}
	if this.PeriodLimitMb != that.PeriodLimitMb {
		return false
	}
	if this.LimitResetTime != that.LimitResetTime {
		return false
	}
	if this.LimitReached != that.LimitReached {
		return false
	}
	if this.IngestlimitsSamplingConfig__NumRequests != that.IngestlimitsSamplingConfig__NumRequests {
		return false
	}
	if this.IngestlimitsSamplingConfig__Period != that.IngestlimitsSamplingConfig__Period {
		return false
	}
	if len(this.UsageGroups) != len(that.UsageGroups) {
		return false
	}
	for i, vx := range this.UsageGroups {
		vy, ok := that.UsageGroups[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &IngestlimitsUsageGroup{}
			}
			if q == nil {
				q = &IngestlimitsUsageGroup{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *IngestlimitsConfig) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*IngestlimitsConfig)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *IngestlimitsUsageGroup) EqualVT(that *IngestlimitsUsageGroup) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.PeriodLimitMb != that.PeriodLimitMb {
		return false
	}
	if this.LimitReached != that.LimitReached {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *IngestlimitsUsageGroup) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*IngestlimitsUsageGroup)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *RelabelConfig) EqualVT(that *RelabelConfig) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.SourceLabels) != len(that.SourceLabels) {
		return false
	}
	for i, vx := range this.SourceLabels {
		vy := that.SourceLabels[i]
		if vx != vy {
			return false
		}
	}
	if this.Separator != that.Separator {
		return false
	}
	if this.Regex != that.Regex {
		return false
	}
	if this.Modulus != that.Modulus {
		return false
	}
	if this.TargetLabel != that.TargetLabel {
		return false
	}
	if this.Replacement != that.Replacement {
		return false
	}
	if this.Action != that.Action {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *RelabelConfig) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*RelabelConfig)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SamplingConfig) EqualVT(that *SamplingConfig) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.UsageGroups) != len(that.UsageGroups) {
		return false
	}
	for i, vx := range this.UsageGroups {
		vy, ok := that.UsageGroups[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &SamplingUsageGroupSampling{}
			}
			if q == nil {
				q = &SamplingUsageGroupSampling{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SamplingConfig) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*SamplingConfig)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SamplingUsageGroupSampling) EqualVT(that *SamplingUsageGroupSampling) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Probability != that.Probability {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SamplingUsageGroupSampling) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*SamplingUsageGroupSampling)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ValidationLimits) EqualVT(that *ValidationLimits) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.IngestionRateMB != that.IngestionRateMB {
		return false
	}
	if this.IngestionBurstSizeMB != that.IngestionBurstSizeMB {
		return false
	}
	if !this.IngestionLimit.EqualVT(that.IngestionLimit) {
		return false
	}
	if this.IngestionBodyLimitMB != that.IngestionBodyLimitMB {
		return false
	}
	if !this.DistributorSampling.EqualVT(that.DistributorSampling) {
		return false
	}
	if this.MaxLabelNameLength != that.MaxLabelNameLength {
		return false
	}
	if this.MaxLabelValueLength != that.MaxLabelValueLength {
		return false
	}
	if this.MaxLabelNamesPerSeries != that.MaxLabelNamesPerSeries {
		return false
	}
	if this.MaxSessionsPerSeries != that.MaxSessionsPerSeries {
		return false
	}
	if this.EnforceLabelsOrder != that.EnforceLabelsOrder {
		return false
	}
	if this.MaxProfileSizeBytes != that.MaxProfileSizeBytes {
		return false
	}
	if this.MaxProfileStacktraceSamples != that.MaxProfileStacktraceSamples {
		return false
	}
	if this.MaxProfileStacktraceSampleLabels != that.MaxProfileStacktraceSampleLabels {
		return false
	}
	if this.MaxProfileStacktraceDepth != that.MaxProfileStacktraceDepth {
		return false
	}
	if this.MaxProfileSymbolValueLength != that.MaxProfileSymbolValueLength {
		return false
	}
	if len(this.DistributorUsageGroups) != len(that.DistributorUsageGroups) {
		return false
	}
	for i, vx := range this.DistributorUsageGroups {
		vy, ok := that.DistributorUsageGroups[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if this.DistributorAggregationWindow != that.DistributorAggregationWindow {
		return false
	}
	if this.DistributorAggregationPeriod != that.DistributorAggregationPeriod {
		return false
	}
	if len(this.IngestionRelabelingRules) != len(that.IngestionRelabelingRules) {
		return false
	}
	for i, vx := range this.IngestionRelabelingRules {
		vy := that.IngestionRelabelingRules[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &RelabelConfig{}
			}
			if q == nil {
				q = &RelabelConfig{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.IngestionRelabelingDefaultRulesPosition != that.IngestionRelabelingDefaultRulesPosition {
		return false
	}
	if this.IngestionTenantShardSize != that.IngestionTenantShardSize {
		return false
	}
	if this.IngestionArtificialDelay != that.IngestionArtificialDelay {
		return false
	}
	if this.MaxLocalSeriesPerTenant != that.MaxLocalSeriesPerTenant {
		return false
	}
	if this.MaxGlobalSeriesPerTenant != that.MaxGlobalSeriesPerTenant {
		return false
	}
	if this.MaxQueryLookback != that.MaxQueryLookback {
		return false
	}
	if this.MaxQueryLength != that.MaxQueryLength {
		return false
	}
	if this.MaxQueryParallelism != that.MaxQueryParallelism {
		return false
	}
	if this.QueryAnalysisEnabled != that.QueryAnalysisEnabled {
		return false
	}
	if this.QueryAnalysisSeriesEnabled != that.QueryAnalysisSeriesEnabled {
		return false
	}
	if this.MaxFlameGraphNodesDefault != that.MaxFlameGraphNodesDefault {
		return false
	}
	if this.MaxFlameGraphNodesMax != that.MaxFlameGraphNodesMax {
		return false
	}
	if this.StoreGatewayTenantShardSize != that.StoreGatewayTenantShardSize {
		return false
	}
	if this.QuerySplitDuration != that.QuerySplitDuration {
		return false
	}
	if this.CompactorBlocksRetentionPeriod != that.CompactorBlocksRetentionPeriod {
		return false
	}
	if this.CompactorSplitAndMergeShards != that.CompactorSplitAndMergeShards {
		return false
	}
	if this.CompactorSplitAndMergeStageSize != that.CompactorSplitAndMergeStageSize {
		return false
	}
	if this.CompactorSplitGroups != that.CompactorSplitGroups {
		return false
	}
	if this.CompactorTenantShardSize != that.CompactorTenantShardSize {
		return false
	}
	if this.CompactorPartialBlockDeletionDelay != that.CompactorPartialBlockDeletionDelay {
		return false
	}
	if this.CompactorDownsamplerEnabled != that.CompactorDownsamplerEnabled {
		return false
	}
	if this.S3SSEType != that.S3SSEType {
		return false
	}
	if this.S3SSEKMSKeyID != that.S3SSEKMSKeyID {
		return false
	}
	if this.S3SSEKMSEncryptionContext != that.S3SSEKMSEncryptionContext {
		return false
	}
	if this.RejectOlderThan != that.RejectOlderThan {
		return false
	}
	if this.RejectNewerThan != that.RejectNewerThan {
		return false
	}
	if this.WritepathConfig__WritePath != that.WritepathConfig__WritePath {
		return false
	}
	if this.WritepathConfig__IngesterWeight != that.WritepathConfig__IngesterWeight {
		return false
	}
	if this.WritepathConfig__SegmentWriterWeight != that.WritepathConfig__SegmentWriterWeight {
		return false
	}
	if this.WritepathConfig__SegmentWriterTimeout != that.WritepathConfig__SegmentWriterTimeout {
		return false
	}
	if this.WritepathConfig__Compression != that.WritepathConfig__Compression {
		return false
	}
	if this.WritepathConfig__AsyncIngest != that.WritepathConfig__AsyncIngest {
		return false
	}
	if this.ReadpathConfig__EnableQueryBackend != that.ReadpathConfig__EnableQueryBackend {
		return false
	}
	if this.ReadpathConfig__EnableQueryBackendFrom != that.ReadpathConfig__EnableQueryBackendFrom {
		return false
	}
	if this.RetentionConfig__RetentionPeriod != that.RetentionConfig__RetentionPeriod {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__TenantShards != that.AdaptiveplacementPlacementLimits__TenantShards {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__DefaultDatasetShards != that.AdaptiveplacementPlacementLimits__DefaultDatasetShards {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__LoadBalancing != that.AdaptiveplacementPlacementLimits__LoadBalancing {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__MinDatasetShards != that.AdaptiveplacementPlacementLimits__MinDatasetShards {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__MaxDatasetShards != that.AdaptiveplacementPlacementLimits__MaxDatasetShards {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__UnitSizeBytes != that.AdaptiveplacementPlacementLimits__UnitSizeBytes {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__BurstWindow != that.AdaptiveplacementPlacementLimits__BurstWindow {
		return false
	}
	if this.AdaptiveplacementPlacementLimits__DecayWindow != that.AdaptiveplacementPlacementLimits__DecayWindow {
		return false
	}
	if len(this.RecordingRules) != len(that.RecordingRules) {
		return false
	}
	for i, vx := range this.RecordingRules {
		vy := that.RecordingRules[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &v1.RecordingRule{}
			}
			if q == nil {
				q = &v1.RecordingRule{}
			}
			if equal, ok := interface{}(p).(interface{ EqualVT(*v1.RecordingRule) bool }); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if this.ValidationSymbolizer__Enabled != that.ValidationSymbolizer__Enabled {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ValidationLimits) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*ValidationLimits)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (m *IngestlimitsConfig) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestlimitsConfig) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *IngestlimitsConfig) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UsageGroups) > 0 {
		for k := range m.UsageGroups {
			v := m.UsageGroups[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = protohelpers.EncodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IngestlimitsSamplingConfig__Period != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.IngestlimitsSamplingConfig__Period))
		i--
		dAtA[i] = 0x30
	}
	if m.IngestlimitsSamplingConfig__NumRequests != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.IngestlimitsSamplingConfig__NumRequests))
		i--
		dAtA[i] = 0x28
	}
	if m.LimitReached {
		i--
		if m.LimitReached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.LimitResetTime != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.LimitResetTime))
		i--
		dAtA[i] = 0x18
	}
	if m.PeriodLimitMb != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.PeriodLimitMb))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PeriodType) > 0 {
		i -= len(m.PeriodType)
		copy(dAtA[i:], m.PeriodType)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.PeriodType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngestlimitsUsageGroup) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestlimitsUsageGroup) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *IngestlimitsUsageGroup) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.LimitReached {
		i--
		if m.LimitReached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PeriodLimitMb != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.PeriodLimitMb))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RelabelConfig) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelabelConfig) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *RelabelConfig) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Replacement) > 0 {
		i -= len(m.Replacement)
		copy(dAtA[i:], m.Replacement)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Replacement)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TargetLabel) > 0 {
		i -= len(m.TargetLabel)
		copy(dAtA[i:], m.TargetLabel)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.TargetLabel)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Modulus != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Modulus))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Regex) > 0 {
		i -= len(m.Regex)
		copy(dAtA[i:], m.Regex)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Regex)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Separator) > 0 {
		i -= len(m.Separator)
		copy(dAtA[i:], m.Separator)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Separator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceLabels) > 0 {
		for iNdEx := len(m.SourceLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceLabels[iNdEx])
			copy(dAtA[i:], m.SourceLabels[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.SourceLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SamplingConfig) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SamplingConfig) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SamplingConfig) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UsageGroups) > 0 {
		for k := range m.UsageGroups {
			v := m.UsageGroups[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = protohelpers.EncodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SamplingUsageGroupSampling) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SamplingUsageGroupSampling) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SamplingUsageGroupSampling) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Probability != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Probability))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ValidationLimits) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationLimits) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ValidationLimits) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.ValidationSymbolizer__Enabled {
		i--
		if m.ValidationSymbolizer__Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if len(m.RecordingRules) > 0 {
		for iNdEx := len(m.RecordingRules) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RecordingRules[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RecordingRules[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = protohelpers.EncodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.AdaptiveplacementPlacementLimits__DecayWindow != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__DecayWindow))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.AdaptiveplacementPlacementLimits__BurstWindow != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__BurstWindow))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.AdaptiveplacementPlacementLimits__UnitSizeBytes != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__UnitSizeBytes))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.AdaptiveplacementPlacementLimits__MaxDatasetShards != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__MaxDatasetShards))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.AdaptiveplacementPlacementLimits__MinDatasetShards != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__MinDatasetShards))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if len(m.AdaptiveplacementPlacementLimits__LoadBalancing) > 0 {
		i -= len(m.AdaptiveplacementPlacementLimits__LoadBalancing)
		copy(dAtA[i:], m.AdaptiveplacementPlacementLimits__LoadBalancing)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.AdaptiveplacementPlacementLimits__LoadBalancing)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if m.AdaptiveplacementPlacementLimits__DefaultDatasetShards != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__DefaultDatasetShards))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.AdaptiveplacementPlacementLimits__TenantShards != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AdaptiveplacementPlacementLimits__TenantShards))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.RetentionConfig__RetentionPeriod != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.RetentionConfig__RetentionPeriod))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.ReadpathConfig__EnableQueryBackendFrom != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ReadpathConfig__EnableQueryBackendFrom))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.ReadpathConfig__EnableQueryBackend {
		i--
		if m.ReadpathConfig__EnableQueryBackend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.WritepathConfig__AsyncIngest {
		i--
		if m.WritepathConfig__AsyncIngest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if len(m.WritepathConfig__Compression) > 0 {
		i -= len(m.WritepathConfig__Compression)
		copy(dAtA[i:], m.WritepathConfig__Compression)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.WritepathConfig__Compression)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.WritepathConfig__SegmentWriterTimeout != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.WritepathConfig__SegmentWriterTimeout))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.WritepathConfig__SegmentWriterWeight != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WritepathConfig__SegmentWriterWeight))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x85
	}
	if m.WritepathConfig__IngesterWeight != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WritepathConfig__IngesterWeight))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfd
	}
	if len(m.WritepathConfig__WritePath) > 0 {
		i -= len(m.WritepathConfig__WritePath)
		copy(dAtA[i:], m.WritepathConfig__WritePath)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.WritepathConfig__WritePath)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.RejectNewerThan != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.RejectNewerThan))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.RejectOlderThan != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.RejectOlderThan))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if len(m.S3SSEKMSEncryptionContext) > 0 {
		i -= len(m.S3SSEKMSEncryptionContext)
		copy(dAtA[i:], m.S3SSEKMSEncryptionContext)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.S3SSEKMSEncryptionContext)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.S3SSEKMSKeyID) > 0 {
		i -= len(m.S3SSEKMSKeyID)
		copy(dAtA[i:], m.S3SSEKMSKeyID)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.S3SSEKMSKeyID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.S3SSEType) > 0 {
		i -= len(m.S3SSEType)
		copy(dAtA[i:], m.S3SSEType)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.S3SSEType)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.CompactorDownsamplerEnabled {
		i--
		if m.CompactorDownsamplerEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.CompactorPartialBlockDeletionDelay != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CompactorPartialBlockDeletionDelay))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.CompactorTenantShardSize != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CompactorTenantShardSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.CompactorSplitGroups != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CompactorSplitGroups))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.CompactorSplitAndMergeStageSize != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CompactorSplitAndMergeStageSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.CompactorSplitAndMergeShards != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CompactorSplitAndMergeShards))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.CompactorBlocksRetentionPeriod != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CompactorBlocksRetentionPeriod))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.QuerySplitDuration != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.QuerySplitDuration))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.StoreGatewayTenantShardSize != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.StoreGatewayTenantShardSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.MaxFlameGraphNodesMax != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxFlameGraphNodesMax))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.MaxFlameGraphNodesDefault != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxFlameGraphNodesDefault))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.QueryAnalysisSeriesEnabled {
		i--
		if m.QueryAnalysisSeriesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.QueryAnalysisEnabled {
		i--
		if m.QueryAnalysisEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.MaxQueryParallelism != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxQueryParallelism))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.MaxQueryLength != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxQueryLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.MaxQueryLookback != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxQueryLookback))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxGlobalSeriesPerTenant != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxGlobalSeriesPerTenant))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.MaxLocalSeriesPerTenant != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxLocalSeriesPerTenant))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.IngestionArtificialDelay != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.IngestionArtificialDelay))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IngestionTenantShardSize != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.IngestionTenantShardSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.IngestionRelabelingDefaultRulesPosition) > 0 {
		i -= len(m.IngestionRelabelingDefaultRulesPosition)
		copy(dAtA[i:], m.IngestionRelabelingDefaultRulesPosition)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.IngestionRelabelingDefaultRulesPosition)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.IngestionRelabelingRules) > 0 {
		for iNdEx := len(m.IngestionRelabelingRules) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.IngestionRelabelingRules[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.DistributorAggregationPeriod != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.DistributorAggregationPeriod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.DistributorAggregationWindow != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.DistributorAggregationWindow))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.DistributorUsageGroups) > 0 {
		for k := range m.DistributorUsageGroups {
			v := m.DistributorUsageGroups[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = protohelpers.EncodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.MaxProfileSymbolValueLength != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxProfileSymbolValueLength))
		i--
		dAtA[i] = 0x78
	}
	if m.MaxProfileStacktraceDepth != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxProfileStacktraceDepth))
		i--
		dAtA[i] = 0x70
	}
	if m.MaxProfileStacktraceSampleLabels != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxProfileStacktraceSampleLabels))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxProfileStacktraceSamples != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxProfileStacktraceSamples))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxProfileSizeBytes != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxProfileSizeBytes))
		i--
		dAtA[i] = 0x58
	}
	if m.EnforceLabelsOrder {
		i--
		if m.EnforceLabelsOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.MaxSessionsPerSeries != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxSessionsPerSeries))
		i--
		dAtA[i] = 0x48
	}
	if m.MaxLabelNamesPerSeries != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxLabelNamesPerSeries))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxLabelValueLength != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxLabelValueLength))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxLabelNameLength != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxLabelNameLength))
		i--
		dAtA[i] = 0x30
	}
	if m.DistributorSampling != nil {
		size, err := m.DistributorSampling.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	}
	if m.IngestionBodyLimitMB != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.IngestionBodyLimitMB))))
		i--
		dAtA[i] = 0x25
	}
	if m.IngestionLimit != nil {
		size, err := m.IngestionLimit.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.IngestionBurstSizeMB != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.IngestionBurstSizeMB))))
		i--
		dAtA[i] = 0x15
	}
	if m.IngestionRateMB != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.IngestionRateMB))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *IngestlimitsConfig) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeriodType)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.PeriodLimitMb != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.PeriodLimitMb))
	}
	if m.LimitResetTime != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.LimitResetTime))
	}
	if m.LimitReached {
		n += 2
	}
	if m.IngestlimitsSamplingConfig__NumRequests != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.IngestlimitsSamplingConfig__NumRequests))
	}
	if m.IngestlimitsSamplingConfig__Period != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.IngestlimitsSamplingConfig__Period))
	}
	if len(m.UsageGroups) > 0 {
		for k, v := range m.UsageGroups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + protohelpers.SizeOfVarint(uint64(l))
			mapEntrySize := 1 + len(k) + protohelpers.SizeOfVarint(uint64(len(k))) + l
			n += mapEntrySize + 1 + protohelpers.SizeOfVarint(uint64(mapEntrySize))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *IngestlimitsUsageGroup) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeriodLimitMb != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.PeriodLimitMb))
	}
	if m.LimitReached {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *RelabelConfig) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SourceLabels) > 0 {
		for _, s := range m.SourceLabels {
			l = len(s)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.Separator)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.Regex)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Modulus != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Modulus))
	}
	l = len(m.TargetLabel)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.Replacement)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *SamplingConfig) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UsageGroups) > 0 {
		for k, v := range m.UsageGroups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + protohelpers.SizeOfVarint(uint64(l))
			mapEntrySize := 1 + len(k) + protohelpers.SizeOfVarint(uint64(len(k))) + l
			n += mapEntrySize + 1 + protohelpers.SizeOfVarint(uint64(mapEntrySize))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SamplingUsageGroupSampling) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Probability != 0 {
		n += 5
	}
	n += len(m.unknownFields)
	return n
}

func (m *ValidationLimits) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IngestionRateMB != 0 {
		n += 5
	}
	if m.IngestionBurstSizeMB != 0 {
		n += 5
	}
	if m.IngestionLimit != nil {
		l = m.IngestionLimit.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.IngestionBodyLimitMB != 0 {
		n += 5
	}
	if m.DistributorSampling != nil {
		l = m.DistributorSampling.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.MaxLabelNameLength != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxLabelNameLength))
	}
	if m.MaxLabelValueLength != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxLabelValueLength))
	}
	if m.MaxLabelNamesPerSeries != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxLabelNamesPerSeries))
	}
	if m.MaxSessionsPerSeries != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxSessionsPerSeries))
	}
	if m.EnforceLabelsOrder {
		n += 2
	}
	if m.MaxProfileSizeBytes != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxProfileSizeBytes))
	}
	if m.MaxProfileStacktraceSamples != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxProfileStacktraceSamples))
	}
	if m.MaxProfileStacktraceSampleLabels != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxProfileStacktraceSampleLabels))
	}
	if m.MaxProfileStacktraceDepth != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxProfileStacktraceDepth))
	}
	if m.MaxProfileSymbolValueLength != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MaxProfileSymbolValueLength))
	}
	if len(m.DistributorUsageGroups) > 0 {
		for k, v := range m.DistributorUsageGroups {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + protohelpers.SizeOfVarint(uint64(len(k))) + 1 + len(v) + protohelpers.SizeOfVarint(uint64(len(v)))
			n += mapEntrySize + 2 + protohelpers.SizeOfVarint(uint64(mapEntrySize))
		}
	}
	if m.DistributorAggregationWindow != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.DistributorAggregationWindow))
	}
	if m.DistributorAggregationPeriod != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.DistributorAggregationPeriod))
	}
	if len(m.IngestionRelabelingRules) > 0 {
		for _, e := range m.IngestionRelabelingRules {
			l = e.SizeVT()
			n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.IngestionRelabelingDefaultRulesPosition)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.IngestionTenantShardSize != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.IngestionTenantShardSize))
	}
	if m.IngestionArtificialDelay != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.IngestionArtificialDelay))
	}
	if m.MaxLocalSeriesPerTenant != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxLocalSeriesPerTenant))
	}
	if m.MaxGlobalSeriesPerTenant != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxGlobalSeriesPerTenant))
	}
	if m.MaxQueryLookback != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxQueryLookback))
	}
	if m.MaxQueryLength != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxQueryLength))
	}
	if m.MaxQueryParallelism != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxQueryParallelism))
	}
	if m.QueryAnalysisEnabled {
		n += 3
	}
	if m.QueryAnalysisSeriesEnabled {
		n += 3
	}
	if m.MaxFlameGraphNodesDefault != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxFlameGraphNodesDefault))
	}
	if m.MaxFlameGraphNodesMax != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxFlameGraphNodesMax))
	}
	if m.StoreGatewayTenantShardSize != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.StoreGatewayTenantShardSize))
	}
	if m.QuerySplitDuration != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.QuerySplitDuration))
	}
	if m.CompactorBlocksRetentionPeriod != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CompactorBlocksRetentionPeriod))
	}
	if m.CompactorSplitAndMergeShards != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CompactorSplitAndMergeShards))
	}
	if m.CompactorSplitAndMergeStageSize != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CompactorSplitAndMergeStageSize))
	}
	if m.CompactorSplitGroups != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CompactorSplitGroups))
	}
	if m.CompactorTenantShardSize != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CompactorTenantShardSize))
	}
	if m.CompactorPartialBlockDeletionDelay != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CompactorPartialBlockDeletionDelay))
	}
	if m.CompactorDownsamplerEnabled {
		n += 3
	}
	l = len(m.S3SSEType)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.S3SSEKMSKeyID)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.S3SSEKMSEncryptionContext)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.RejectOlderThan != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.RejectOlderThan))
	}
	if m.RejectNewerThan != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.RejectNewerThan))
	}
	l = len(m.WritepathConfig__WritePath)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.WritepathConfig__IngesterWeight != 0 {
		n += 6
	}
	if m.WritepathConfig__SegmentWriterWeight != 0 {
		n += 6
	}
	if m.WritepathConfig__SegmentWriterTimeout != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.WritepathConfig__SegmentWriterTimeout))
	}
	l = len(m.WritepathConfig__Compression)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.WritepathConfig__AsyncIngest {
		n += 3
	}
	if m.ReadpathConfig__EnableQueryBackend {
		n += 3
	}
	if m.ReadpathConfig__EnableQueryBackendFrom != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.ReadpathConfig__EnableQueryBackendFrom))
	}
	if m.RetentionConfig__RetentionPeriod != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.RetentionConfig__RetentionPeriod))
	}
	if m.AdaptiveplacementPlacementLimits__TenantShards != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__TenantShards))
	}
	if m.AdaptiveplacementPlacementLimits__DefaultDatasetShards != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__DefaultDatasetShards))
	}
	l = len(m.AdaptiveplacementPlacementLimits__LoadBalancing)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.AdaptiveplacementPlacementLimits__MinDatasetShards != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__MinDatasetShards))
	}
	if m.AdaptiveplacementPlacementLimits__MaxDatasetShards != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__MaxDatasetShards))
	}
	if m.AdaptiveplacementPlacementLimits__UnitSizeBytes != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__UnitSizeBytes))
	}
	if m.AdaptiveplacementPlacementLimits__BurstWindow != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__BurstWindow))
	}
	if m.AdaptiveplacementPlacementLimits__DecayWindow != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AdaptiveplacementPlacementLimits__DecayWindow))
	}
	if len(m.RecordingRules) > 0 {
		for _, e := range m.RecordingRules {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if m.ValidationSymbolizer__Enabled {
		n += 3
	}
	n += len(m.unknownFields)
	return n
}

func (m *IngestlimitsConfig) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestlimitsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestlimitsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeriodType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodLimitMb", wireType)
			}
			m.PeriodLimitMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodLimitMb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitResetTime", wireType)
			}
			m.LimitResetTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitResetTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitReached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitReached = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestlimitsSamplingConfig__NumRequests", wireType)
			}
			m.IngestlimitsSamplingConfig__NumRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngestlimitsSamplingConfig__NumRequests |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestlimitsSamplingConfig__Period", wireType)
			}
			m.IngestlimitsSamplingConfig__Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngestlimitsSamplingConfig__Period |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsageGroups == nil {
				m.UsageGroups = make(map[string]*IngestlimitsUsageGroup)
			}
			var mapkey string
			var mapvalue *IngestlimitsUsageGroup
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return protohelpers.ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return protohelpers.ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return protohelpers.ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return protohelpers.ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IngestlimitsUsageGroup{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := protohelpers.Skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return protohelpers.ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UsageGroups[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestlimitsUsageGroup) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestlimitsUsageGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestlimitsUsageGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodLimitMb", wireType)
			}
			m.PeriodLimitMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodLimitMb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitReached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitReached = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelabelConfig) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelabelConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelabelConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceLabels = append(m.SourceLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Separator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Separator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulus", wireType)
			}
			m.Modulus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modulus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replacement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replacement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SamplingConfig) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SamplingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SamplingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsageGroups == nil {
				m.UsageGroups = make(map[string]*SamplingUsageGroupSampling)
			}
			var mapkey string
			var mapvalue *SamplingUsageGroupSampling
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return protohelpers.ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return protohelpers.ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return protohelpers.ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return protohelpers.ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SamplingUsageGroupSampling{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := protohelpers.Skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return protohelpers.ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UsageGroups[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SamplingUsageGroupSampling) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SamplingUsageGroupSampling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SamplingUsageGroupSampling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probability", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Probability = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationLimits) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionRateMB", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.IngestionRateMB = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionBurstSizeMB", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.IngestionBurstSizeMB = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngestionLimit == nil {
				m.IngestionLimit = &IngestlimitsConfig{}
			}
			if err := m.IngestionLimit.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionBodyLimitMB", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.IngestionBodyLimitMB = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributorSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DistributorSampling == nil {
				m.DistributorSampling = &SamplingConfig{}
			}
			if err := m.DistributorSampling.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLabelNameLength", wireType)
			}
			m.MaxLabelNameLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLabelNameLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLabelValueLength", wireType)
			}
			m.MaxLabelValueLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLabelValueLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLabelNamesPerSeries", wireType)
			}
			m.MaxLabelNamesPerSeries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLabelNamesPerSeries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessionsPerSeries", wireType)
			}
			m.MaxSessionsPerSeries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessionsPerSeries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforceLabelsOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnforceLabelsOrder = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProfileSizeBytes", wireType)
			}
			m.MaxProfileSizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProfileSizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProfileStacktraceSamples", wireType)
			}
			m.MaxProfileStacktraceSamples = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProfileStacktraceSamples |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProfileStacktraceSampleLabels", wireType)
			}
			m.MaxProfileStacktraceSampleLabels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProfileStacktraceSampleLabels |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProfileStacktraceDepth", wireType)
			}
			m.MaxProfileStacktraceDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProfileStacktraceDepth |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProfileSymbolValueLength", wireType)
			}
			m.MaxProfileSymbolValueLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProfileSymbolValueLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributorUsageGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DistributorUsageGroups == nil {
				m.DistributorUsageGroups = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return protohelpers.ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return protohelpers.ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return protohelpers.ErrInvalidLength
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return protohelpers.ErrInvalidLength
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := protohelpers.Skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return protohelpers.ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DistributorUsageGroups[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributorAggregationWindow", wireType)
			}
			m.DistributorAggregationWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributorAggregationWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributorAggregationPeriod", wireType)
			}
			m.DistributorAggregationPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributorAggregationPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionRelabelingRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngestionRelabelingRules = append(m.IngestionRelabelingRules, &RelabelConfig{})
			if err := m.IngestionRelabelingRules[len(m.IngestionRelabelingRules)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionRelabelingDefaultRulesPosition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngestionRelabelingDefaultRulesPosition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionTenantShardSize", wireType)
			}
			m.IngestionTenantShardSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngestionTenantShardSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionArtificialDelay", wireType)
			}
			m.IngestionArtificialDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngestionArtificialDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLocalSeriesPerTenant", wireType)
			}
			m.MaxLocalSeriesPerTenant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLocalSeriesPerTenant |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGlobalSeriesPerTenant", wireType)
			}
			m.MaxGlobalSeriesPerTenant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxGlobalSeriesPerTenant |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueryLookback", wireType)
			}
			m.MaxQueryLookback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueryLookback |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueryLength", wireType)
			}
			m.MaxQueryLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueryLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueryParallelism", wireType)
			}
			m.MaxQueryParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueryParallelism |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryAnalysisEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryAnalysisEnabled = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryAnalysisSeriesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryAnalysisSeriesEnabled = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFlameGraphNodesDefault", wireType)
			}
			m.MaxFlameGraphNodesDefault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFlameGraphNodesDefault |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFlameGraphNodesMax", wireType)
			}
			m.MaxFlameGraphNodesMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFlameGraphNodesMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreGatewayTenantShardSize", wireType)
			}
			m.StoreGatewayTenantShardSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreGatewayTenantShardSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuerySplitDuration", wireType)
			}
			m.QuerySplitDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuerySplitDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorBlocksRetentionPeriod", wireType)
			}
			m.CompactorBlocksRetentionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactorBlocksRetentionPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorSplitAndMergeShards", wireType)
			}
			m.CompactorSplitAndMergeShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactorSplitAndMergeShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorSplitAndMergeStageSize", wireType)
			}
			m.CompactorSplitAndMergeStageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactorSplitAndMergeStageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorSplitGroups", wireType)
			}
			m.CompactorSplitGroups = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactorSplitGroups |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorTenantShardSize", wireType)
			}
			m.CompactorTenantShardSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactorTenantShardSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorPartialBlockDeletionDelay", wireType)
			}
			m.CompactorPartialBlockDeletionDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactorPartialBlockDeletionDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactorDownsamplerEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CompactorDownsamplerEnabled = bool(v != 0)
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3SSEType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3SSEType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3SSEKMSKeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3SSEKMSKeyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3SSEKMSEncryptionContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3SSEKMSEncryptionContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectOlderThan", wireType)
			}
			m.RejectOlderThan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RejectOlderThan |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectNewerThan", wireType)
			}
			m.RejectNewerThan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RejectNewerThan |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritepathConfig__WritePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WritepathConfig__WritePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritepathConfig__IngesterWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WritepathConfig__IngesterWeight = float32(math.Float32frombits(v))
		case 48:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritepathConfig__SegmentWriterWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WritepathConfig__SegmentWriterWeight = float32(math.Float32frombits(v))
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritepathConfig__SegmentWriterTimeout", wireType)
			}
			m.WritepathConfig__SegmentWriterTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WritepathConfig__SegmentWriterTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritepathConfig__Compression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WritepathConfig__Compression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritepathConfig__AsyncIngest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WritepathConfig__AsyncIngest = bool(v != 0)
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadpathConfig__EnableQueryBackend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadpathConfig__EnableQueryBackend = bool(v != 0)
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadpathConfig__EnableQueryBackendFrom", wireType)
			}
			m.ReadpathConfig__EnableQueryBackendFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadpathConfig__EnableQueryBackendFrom |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionConfig__RetentionPeriod", wireType)
			}
			m.RetentionConfig__RetentionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionConfig__RetentionPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__TenantShards", wireType)
			}
			m.AdaptiveplacementPlacementLimits__TenantShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__TenantShards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__DefaultDatasetShards", wireType)
			}
			m.AdaptiveplacementPlacementLimits__DefaultDatasetShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__DefaultDatasetShards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__LoadBalancing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdaptiveplacementPlacementLimits__LoadBalancing = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__MinDatasetShards", wireType)
			}
			m.AdaptiveplacementPlacementLimits__MinDatasetShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__MinDatasetShards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__MaxDatasetShards", wireType)
			}
			m.AdaptiveplacementPlacementLimits__MaxDatasetShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__MaxDatasetShards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__UnitSizeBytes", wireType)
			}
			m.AdaptiveplacementPlacementLimits__UnitSizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__UnitSizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__BurstWindow", wireType)
			}
			m.AdaptiveplacementPlacementLimits__BurstWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__BurstWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveplacementPlacementLimits__DecayWindow", wireType)
			}
			m.AdaptiveplacementPlacementLimits__DecayWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdaptiveplacementPlacementLimits__DecayWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordingRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordingRules = append(m.RecordingRules, &v1.RecordingRule{})
			if unmarshal, ok := interface{}(m.RecordingRules[len(m.RecordingRules)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RecordingRules[len(m.RecordingRules)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationSymbolizer__Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidationSymbolizer__Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
