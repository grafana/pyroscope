syntax = "proto3";

package adaptive_placement;

// DistributionStats includes the data the Placement is built based on.
message DistributionStats {
  repeated TenantStats tenants = 1;
  repeated DatasetStats datasets = 2;
  repeated ShardStats shards = 3;
}

message TenantStats {
  string tenant_id = 1;
}

message DatasetStats {
  uint32 tenant = 1; // Reference to TenantStats.
  string name = 2;
  // Shard value is a reference to ShardStats.
  repeated uint32 shards = 3;
  // Data rate in bytes per second for each shard.
  // The dataset size is measured after being encoded
  // in the block wire format.
  repeated uint64 usage = 4;
  // Standard deviation of the data rate across shards
  // aggregated within a sliding time window.
  uint64 std_dev = 5;
}

message ShardStats {
  uint32 id = 1;
  string owner = 2;
}

message PlacementLimits {
  uint32 tenant_shard_limit = 1;
  uint32 dataset_shard_limit = 2;
  LoadBalancing load_balancing = 3;
}

enum LoadBalancing {
  LOAD_BALANCING_UNSPECIFIED = 0;
  LOAD_BALANCING_FINGERPRINT = 1;
  LOAD_BALANCING_ROUND_ROBIN = 2;
}

message PlacementRules {
  PlacementLimits defaults = 1;
  repeated TenantPlacement tenants = 2;
  repeated DatasetPlacement datasets = 3;
}

message TenantPlacement {
  string tenant_id = 1;
  // Tenant placement limits take precedence
  // over the default values. The limits are
  // used, if dataset placement limits are not
  // defined.
  PlacementLimits limits = 2;
}

message DatasetPlacement {
  uint32 tenant = 1;
  string name = 2;
  uint32 shard_limit = 3;
  LoadBalancing load_balancing = 4;
}
