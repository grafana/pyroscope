// Code generated by mockery. DO NOT EDIT.

package mockfrontend

import (
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockLimits is an autogenerated mock type for the Limits type
type MockLimits struct {
	mock.Mock
}

type MockLimits_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLimits) EXPECT() *MockLimits_Expecter {
	return &MockLimits_Expecter{mock: &_m.Mock}
}

// MaxFlameGraphNodesDefault provides a mock function with given fields: _a0
func (_m *MockLimits) MaxFlameGraphNodesDefault(_a0 string) int {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MaxFlameGraphNodesDefault")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockLimits_MaxFlameGraphNodesDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxFlameGraphNodesDefault'
type MockLimits_MaxFlameGraphNodesDefault_Call struct {
	*mock.Call
}

// MaxFlameGraphNodesDefault is a helper method to define mock.On call
//   - _a0 string
func (_e *MockLimits_Expecter) MaxFlameGraphNodesDefault(_a0 interface{}) *MockLimits_MaxFlameGraphNodesDefault_Call {
	return &MockLimits_MaxFlameGraphNodesDefault_Call{Call: _e.mock.On("MaxFlameGraphNodesDefault", _a0)}
}

func (_c *MockLimits_MaxFlameGraphNodesDefault_Call) Run(run func(_a0 string)) *MockLimits_MaxFlameGraphNodesDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_MaxFlameGraphNodesDefault_Call) Return(_a0 int) *MockLimits_MaxFlameGraphNodesDefault_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_MaxFlameGraphNodesDefault_Call) RunAndReturn(run func(string) int) *MockLimits_MaxFlameGraphNodesDefault_Call {
	_c.Call.Return(run)
	return _c
}

// MaxFlameGraphNodesMax provides a mock function with given fields: _a0
func (_m *MockLimits) MaxFlameGraphNodesMax(_a0 string) int {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MaxFlameGraphNodesMax")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockLimits_MaxFlameGraphNodesMax_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxFlameGraphNodesMax'
type MockLimits_MaxFlameGraphNodesMax_Call struct {
	*mock.Call
}

// MaxFlameGraphNodesMax is a helper method to define mock.On call
//   - _a0 string
func (_e *MockLimits_Expecter) MaxFlameGraphNodesMax(_a0 interface{}) *MockLimits_MaxFlameGraphNodesMax_Call {
	return &MockLimits_MaxFlameGraphNodesMax_Call{Call: _e.mock.On("MaxFlameGraphNodesMax", _a0)}
}

func (_c *MockLimits_MaxFlameGraphNodesMax_Call) Run(run func(_a0 string)) *MockLimits_MaxFlameGraphNodesMax_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_MaxFlameGraphNodesMax_Call) Return(_a0 int) *MockLimits_MaxFlameGraphNodesMax_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_MaxFlameGraphNodesMax_Call) RunAndReturn(run func(string) int) *MockLimits_MaxFlameGraphNodesMax_Call {
	_c.Call.Return(run)
	return _c
}

// MaxQueryLength provides a mock function with given fields: tenantID
func (_m *MockLimits) MaxQueryLength(tenantID string) time.Duration {
	ret := _m.Called(tenantID)

	if len(ret) == 0 {
		panic("no return value specified for MaxQueryLength")
	}

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func(string) time.Duration); ok {
		r0 = rf(tenantID)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// MockLimits_MaxQueryLength_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxQueryLength'
type MockLimits_MaxQueryLength_Call struct {
	*mock.Call
}

// MaxQueryLength is a helper method to define mock.On call
//   - tenantID string
func (_e *MockLimits_Expecter) MaxQueryLength(tenantID interface{}) *MockLimits_MaxQueryLength_Call {
	return &MockLimits_MaxQueryLength_Call{Call: _e.mock.On("MaxQueryLength", tenantID)}
}

func (_c *MockLimits_MaxQueryLength_Call) Run(run func(tenantID string)) *MockLimits_MaxQueryLength_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_MaxQueryLength_Call) Return(_a0 time.Duration) *MockLimits_MaxQueryLength_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_MaxQueryLength_Call) RunAndReturn(run func(string) time.Duration) *MockLimits_MaxQueryLength_Call {
	_c.Call.Return(run)
	return _c
}

// MaxQueryLookback provides a mock function with given fields: tenantID
func (_m *MockLimits) MaxQueryLookback(tenantID string) time.Duration {
	ret := _m.Called(tenantID)

	if len(ret) == 0 {
		panic("no return value specified for MaxQueryLookback")
	}

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func(string) time.Duration); ok {
		r0 = rf(tenantID)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// MockLimits_MaxQueryLookback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxQueryLookback'
type MockLimits_MaxQueryLookback_Call struct {
	*mock.Call
}

// MaxQueryLookback is a helper method to define mock.On call
//   - tenantID string
func (_e *MockLimits_Expecter) MaxQueryLookback(tenantID interface{}) *MockLimits_MaxQueryLookback_Call {
	return &MockLimits_MaxQueryLookback_Call{Call: _e.mock.On("MaxQueryLookback", tenantID)}
}

func (_c *MockLimits_MaxQueryLookback_Call) Run(run func(tenantID string)) *MockLimits_MaxQueryLookback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_MaxQueryLookback_Call) Return(_a0 time.Duration) *MockLimits_MaxQueryLookback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_MaxQueryLookback_Call) RunAndReturn(run func(string) time.Duration) *MockLimits_MaxQueryLookback_Call {
	_c.Call.Return(run)
	return _c
}

// MaxQueryParallelism provides a mock function with given fields: _a0
func (_m *MockLimits) MaxQueryParallelism(_a0 string) int {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MaxQueryParallelism")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockLimits_MaxQueryParallelism_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxQueryParallelism'
type MockLimits_MaxQueryParallelism_Call struct {
	*mock.Call
}

// MaxQueryParallelism is a helper method to define mock.On call
//   - _a0 string
func (_e *MockLimits_Expecter) MaxQueryParallelism(_a0 interface{}) *MockLimits_MaxQueryParallelism_Call {
	return &MockLimits_MaxQueryParallelism_Call{Call: _e.mock.On("MaxQueryParallelism", _a0)}
}

func (_c *MockLimits_MaxQueryParallelism_Call) Run(run func(_a0 string)) *MockLimits_MaxQueryParallelism_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_MaxQueryParallelism_Call) Return(_a0 int) *MockLimits_MaxQueryParallelism_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_MaxQueryParallelism_Call) RunAndReturn(run func(string) int) *MockLimits_MaxQueryParallelism_Call {
	_c.Call.Return(run)
	return _c
}

// QueryAnalysisEnabled provides a mock function with given fields: _a0
func (_m *MockLimits) QueryAnalysisEnabled(_a0 string) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for QueryAnalysisEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockLimits_QueryAnalysisEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryAnalysisEnabled'
type MockLimits_QueryAnalysisEnabled_Call struct {
	*mock.Call
}

// QueryAnalysisEnabled is a helper method to define mock.On call
//   - _a0 string
func (_e *MockLimits_Expecter) QueryAnalysisEnabled(_a0 interface{}) *MockLimits_QueryAnalysisEnabled_Call {
	return &MockLimits_QueryAnalysisEnabled_Call{Call: _e.mock.On("QueryAnalysisEnabled", _a0)}
}

func (_c *MockLimits_QueryAnalysisEnabled_Call) Run(run func(_a0 string)) *MockLimits_QueryAnalysisEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_QueryAnalysisEnabled_Call) Return(_a0 bool) *MockLimits_QueryAnalysisEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_QueryAnalysisEnabled_Call) RunAndReturn(run func(string) bool) *MockLimits_QueryAnalysisEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// QuerySplitDuration provides a mock function with given fields: _a0
func (_m *MockLimits) QuerySplitDuration(_a0 string) time.Duration {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for QuerySplitDuration")
	}

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func(string) time.Duration); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// MockLimits_QuerySplitDuration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QuerySplitDuration'
type MockLimits_QuerySplitDuration_Call struct {
	*mock.Call
}

// QuerySplitDuration is a helper method to define mock.On call
//   - _a0 string
func (_e *MockLimits_Expecter) QuerySplitDuration(_a0 interface{}) *MockLimits_QuerySplitDuration_Call {
	return &MockLimits_QuerySplitDuration_Call{Call: _e.mock.On("QuerySplitDuration", _a0)}
}

func (_c *MockLimits_QuerySplitDuration_Call) Run(run func(_a0 string)) *MockLimits_QuerySplitDuration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLimits_QuerySplitDuration_Call) Return(_a0 time.Duration) *MockLimits_QuerySplitDuration_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLimits_QuerySplitDuration_Call) RunAndReturn(run func(string) time.Duration) *MockLimits_QuerySplitDuration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLimits creates a new instance of MockLimits. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLimits(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLimits {
	mock := &MockLimits{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
