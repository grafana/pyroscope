package pyroscope

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/grafana/river/diag"
	"github.com/grafana/river/parser"
	"github.com/grafana/river/printer"
	"github.com/stretchr/testify/require"
	"gopkg.in/yaml.v3"
)

// Test_FormatAgentRiverConfig tests that the river config generated by helm is formatted correctly
func Test_FormatAgentRiverConfig(t *testing.T) {
	fdata, err := os.Open("helm/pyroscope/rendered/single-binary.yaml")
	require.NoError(t, err)
	defer fdata.Close()

	values := map[string]interface{}{}
	configString := ``
	dec := yaml.NewDecoder(fdata)
	for dec.Decode(&values) == nil {
		if values["metadata"].(map[string]interface{})["name"] == "grafana-agent-config-pyroscope" {
			configString = values["data"].(map[string]interface{})["config.river"].(string)
			break
		}
	}
	fileName := fmt.Sprintf("%s/config.river", t.TempDir())
	require.NoError(t, os.WriteFile(fileName, []byte(configString), 0o644))
	fi, err := os.Stat(fileName)
	require.NoError(t, err)
	f, err := os.Open(fileName)
	require.NoError(t, err)
	defer f.Close()

	err = format(fileName, fi, f, true)
	var diags diag.Diagnostics
	if errors.As(err, &diags) {
		for _, diag := range diags {
			fmt.Fprintln(os.Stderr, diag)
		}
		t.Error("encountered errors during formatting")
	}
	fmtData, err := os.ReadFile(fileName)
	require.NoError(t, err)
	if diff := cmp.Diff(string(fmtData), configString); diff != "" {
		t.Errorf("Grafana Agent Helm River config file is not formatted mismatch (-want +got):\n%s", diff)
		t.Log("You need to fixes formatting issues in operations/pyroscope/helm/pyroscope/templates/configmap-agent.yaml and run make helm/check.")
	}
}

func format(filename string, fi os.FileInfo, r io.Reader, write bool) error {
	bb, err := io.ReadAll(r)
	if err != nil {
		return err
	}

	f, err := parser.ParseFile(filename, bb)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := printer.Fprint(&buf, f); err != nil {
		return err
	}

	// Add a newline at the end of the file.
	_, _ = buf.Write([]byte{'\n'})

	if !write {
		_, err := io.Copy(os.Stdout, &buf)
		return err
	}

	wf, err := os.OpenFile(filename, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, fi.Mode().Perm())
	if err != nil {
		return err
	}
	defer wf.Close()

	_, err = io.Copy(wf, &buf)
	return err
}
