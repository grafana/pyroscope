package main

import (
	"bytes"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"

	"github.com/grafana/pyroscope/ebpf/dwarfdump"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Please provide musl elf debug files.")
		return
	}
	var es []dwarfdump.Entry
	for _, fp := range os.Args[1:] {
		f, err := os.ReadFile(fp)
		if err != nil {
			panic(err)
		}
		fields := dwarfdump.Dump(fp, fields)
		re := regexp.MustCompile("[^\\d]1\\.([1-2])\\.(\\d+)")
		version := re.FindAllSubmatch(f, -1)
		for _, v := range version {
			fmt.Fprintf(os.Stderr, "%s => v %s \n", fp, v[0])
		}
		if len(version) == 0 {
			panic("no version found" + fp)
		}
		if len(version) > 1 {
			vv := version[0][0]
			for _, v := range version {
				if !bytes.Equal(v[0], vv) {
					panic("multiple versions found" + fp)
				}
			}
		}

		iversion := dwarfdump.Version{}
		iversion.Major = 1
		iversion.Minor, _ = strconv.Atoi(string(version[0][1]))
		iversion.Patch, _ = strconv.Atoi(string(version[0][2]))
		es = append(es, dwarfdump.Entry{
			Version: iversion,
			Offsets: fields,
			SrcFile: fp,
		})
	}
	sort.Slice(es, func(i, j int) bool {
		return es[i].Version.Compare(es[j].Version) > 0
	})
	const header = `
// Code generated by musl_dwarfdump. DO NOT EDIT.
package python

var muslOffsets = map[Version]*MuslOffsets{`
	fmt.Println(header)
	for _, e := range es {
		fmt.Printf("// %d.%d %s\n", e.Version.Major, e.Version.Minor, e.SrcFile)
		fmt.Printf("{%d, %d, %d}:  {\n", e.Version.Major, e.Version.Minor, e.Version.Patch)
		for _, offset := range e.Offsets {
			fmt.Printf("    %s: %d,\n", offset.Name, offset.Offset)
		}
		fmt.Printf("},\n")
	}
	fmt.Println("}")

}

var fields = []dwarfdump.Need{
	{Name: "__pthread", Fields: []dwarfdump.NeedField{
		{"tsd", ""},
	}, Size: true},
}
