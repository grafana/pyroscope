package main

import (
	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"

	"github.com/grafana/pyroscope/ebpf/dwarfdump"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Please provide glibc  elf files.")
		return
	}
	var es []dwarfdump.Entry
	for _, fp := range os.Args[1:] {
		fields := dwarfdump.Dump(fp, pythonFields)
		re := regexp.MustCompile("glibc-2\\.(\\d+)")
		version := re.FindAllSubmatch([]byte(fp), -1)
		if len(version) != 1 {
			panic("no version found" + fp)
		}

		iversion := dwarfdump.Version{}
		iversion.Major = 2
		iversion.Minor, _ = strconv.Atoi(string(version[0][1]))
		iversion.Patch = 0
		es = append(es, dwarfdump.Entry{
			Version: iversion,
			Offsets: fields,
			SrcFile: fp,
		})
	}
	sort.Slice(es, func(i, j int) bool {
		return es[i].Version.Compare(es[j].Version) > 0
	})
	const header = `
// Code generated by glibc_dwarfdump. DO NOT EDIT.
package python

var glibcOffsets = map[Version]*GlibcOffsets{`
	fmt.Println(header)
	for _, e := range es {
		fmt.Printf("// %d.%d %s\n", e.Version.Major, e.Version.Minor, e.SrcFile)
		fmt.Printf("{%d, %d, %d}:  {\n", e.Version.Major, e.Version.Minor, e.Version.Patch)
		for _, offset := range e.Offsets {
			fmt.Printf("    %s: %d,\n", offset.Name, offset.Offset)
		}
		fmt.Printf("},\n")
	}
	fmt.Println("}")

}

var pythonFields = []dwarfdump.Need{
	{Name: "pthread", Fields: []dwarfdump.NeedField{
		{"specific_1stblock", ""},
	}, Size: true},
	{Name: "pthread_key_data", Fields: []dwarfdump.NeedField{
		{"data", ""},
	}, Size: true},
}
