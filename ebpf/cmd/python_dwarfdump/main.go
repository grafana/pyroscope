package main

import (
	"fmt"
	"os"
	"regexp"
	"sort"
	"strconv"

	"github.com/grafana/pyroscope/ebpf/dwarfdump"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Please provide python / libpython elf files.")
		return
	}
	var es []dwarfdump.Entry
	for _, fp := range os.Args[1:] {
		fields := dwarfdump.Dump(fp, pythonFields)
		re := regexp.MustCompile("(\\d+)\\.(\\d+)\\.(\\d+)")
		version := re.FindAllSubmatch([]byte(fp), -1)
		if len(version) != 1 {
			panic("no version found" + fp)
		}

		iversion := dwarfdump.Version{}
		iversion.Major, _ = strconv.Atoi(string(version[0][1]))
		iversion.Minor, _ = strconv.Atoi(string(version[0][2]))
		iversion.Patch, _ = strconv.Atoi(string(version[0][3]))
		es = append(es, dwarfdump.Entry{
			Version: iversion,
			Offsets: fields,
			SrcFile: fp,
		})
	}
	sort.Slice(es, func(i, j int) bool {
		return es[i].Version.Compare(es[j].Version) > 0
	})
	const header = `
// Code generated by python_dwarfdump. DO NOT EDIT.
package python

var pyVersions = map[Version]*UserOffsets{`
	fmt.Println(header)
	for _, e := range es {
		fmt.Printf("// %d.%d.%d %s\n", e.Version.Major, e.Version.Minor, e.Version.Patch, e.SrcFile)
		fmt.Printf("{%d, %d, %d}:  {\n", e.Version.Major, e.Version.Minor, e.Version.Patch)
		for _, offset := range e.Offsets {
			fmt.Printf("    %s: %d,\n", offset.Name, offset.Offset)
		}
		fmt.Printf("},\n")
	}
	fmt.Println("}")

}

var pythonFields = []dwarfdump.Need{

	{Name: "PyVarObject", Fields: []dwarfdump.NeedField{
		{"ob_size", "PyVarObject_ob_size"},
	}},
	{Name: "PyObject", Fields: []dwarfdump.NeedField{
		{"ob_type", "PyObject_ob_type"},
	}},
	{Name: "_typeobject", PrettyName: "PyTypeObject", Fields: []dwarfdump.NeedField{
		{"tp_name", "PyTypeObject_tp_name"},
	}},
	{Name: "PyThreadState", Fields: []dwarfdump.NeedField{
		{"frame", "PyThreadState_frame"},
		{"cframe", "PyThreadState_cframe"},
		{"current_frame", "PyThreadState_current_frame"},
	}},
	{Name: "_PyCFrame", Fields: []dwarfdump.NeedField{
		{"current_frame", "PyCFrame_current_frame"},
	}},
	//typedef struct _frame PyFrameObject;
	{Name: "_frame", PrettyName: "PyFrameObject", Fields: []dwarfdump.NeedField{
		{"f_back", "PyFrameObject_f_back"},
		{"f_code", "PyFrameObject_f_code"},
		{"f_localsplus", "PyFrameObject_f_localsplus"},
	}},
	{Name: "PyCodeObject", Fields: []dwarfdump.NeedField{
		{"co_filename", "PyCodeObject_co_filename"},
		{"co_name", "PyCodeObject_co_name"},
		{"co_varnames", "PyCodeObject_co_varnames"},
		{"co_localsplusnames", "PyCodeObject_co_localsplusnames"},
	}},
	{Name: "PyTupleObject", Fields: []dwarfdump.NeedField{
		{"ob_item", "PyTupleObject_ob_item"},
	}},
	{Name: "_PyInterpreterFrame", Fields: []dwarfdump.NeedField{
		{"f_code", "PyInterpreterFrame_f_code"},
		{"f_executable", "PyInterpreterFrame_f_executable"},
		{"previous", "PyInterpreterFrame_previous"},
		{"localsplus", "PyInterpreterFrame_localsplus"},
		{"owner", "PyInterpreterFrame_owner"},
	}},
	{Name: "_PyRuntimeState", Fields: []dwarfdump.NeedField{
		{"gilstate", "PyRuntimeState_gilstate"},
		{"autoTSSkey", "PyRuntimeState_autoTSSkey"},
	}},
	{Name: "_gilstate_runtime_state", Fields: []dwarfdump.NeedField{
		{"autoTSSkey", "Gilstate_runtime_state_autoTSSkey"},
	}},
	{Name: "_Py_tss_t", Size: true, Fields: []dwarfdump.NeedField{
		{"_is_initialized", "PyTssT_is_initialized"},
		{"_key", "PyTssT_key"},
	}},
	{Name: "PyASCIIObject", PrettyName: "PyASCIIObject", Size: true},
	{Name: "PyCompactUnicodeObject", PrettyName: "PyCompactUnicodeObject", Size: true},

	//{Name: "_is", PrettyName: "PyInterpreterState", Fields: []string{}},
}
